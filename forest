#!/usr/bin/env python
#
#  forest
#  
#  Created by Dan Preston on 12/22/08.
#
#  A utility to manage a suite of related git repositories.
#

from __future__ import with_statement
import sys, commands, os

kToolName		= "forest"
kVersion		= " 1.0"

gRepositories	= {}

#----------------------------------------------------------------------------------------------------------------------------
# ReadConfigFile
#----------------------------------------------------------------------------------------------------------------------------

def	ReadConfigFile( config = ".forest/forest.conf" ):
	section = "global"
	with open( config, 'r' ) as f:
		lmark = '[project "'
		rmark = '"]'
		
		for line in f:
			line = line.strip()
			if line.startswith( lmark ) and line.endswith( rmark ):
				section = line[len(lmark):-len(rmark)]
				gRepositories[section] = {}
			elif line.startswith("#"):
				continue
			elif line.startswith( ";" ):
				continue
			elif line == "":
				continue
			else:
				key, _, value = line.partition("=")
				if value == None:
					sys.exit(-2)
				key = key.strip()
				value = value.strip()
				gRepositories[section][key] = value

#----------------------------------------------------------------------------------------------------------------------------
#	urlForSection
#----------------------------------------------------------------------------------------------------------------------------

def urlForSection( section ):
	user = None
	if "user" in gRepositories[section]:
		user = gRepositories["user"]
	elif "global" in gRepositories and "user" in gRepositories["global"]:
		user = gRepositories["global"]["user"]

	# inject the user name into the url.
	url = gRepositories[section]["url"]
	if user:
		left, seperator, address = url.partition("://")
		if seperator and url.find("@") == -1:
			url = left + seperator + user + "@" + address

	return url

#----------------------------------------------------------------------------------------------------------------------------
# ProcessCommand_help
#----------------------------------------------------------------------------------------------------------------------------

def ProcessCommand_help( helpArgs=None ):
	description="A utility to manage a suite of related git repositories."
	usage = '''Usage: forest COMMAND [command options]

    help    Print out the help for a given command.
    init    Initializes a forest.
    config  Set configuration options on a forest.
    pull    Pulls the latest changes from a forest.
    push    Pushes your local commits to the forest.
    stat    Gets status for all the repositories in the forest.
    tag     Tags a forest.'''
	
	print( kToolName + kVersion + ": " + description + "\n" )
	print( usage )

#----------------------------------------------------------------------------------------------------------------------------
# ProcessCommand_init
#----------------------------------------------------------------------------------------------------------------------------

def	ProcessCommand_init( initArgs ):
	if len(initArgs) != 1:
		ProcessCommand_help( "init" )
		sys.exit( -2 )
	
	repository = initArgs[0]
	
	if os.path.exists( ".forest" ):
		print( "The .forest folder already exists from a previous init." )
	else:
		# Clone the git repository containing the meta data.
		print( "Getting forest meta data from %s..." % repository );
		command = "git clone " + repository + " .forest 2>&1"
		err, output = commands.getstatusoutput( command )
		if err != 0:
			print( "git clone failed! [error %d]" % err )
			sys.exit( err )
		print( "done\n" );
	
		ReadConfigFile()

#----------------------------------------------------------------------------------------------------------------------------
# ProcessCommand_config
#----------------------------------------------------------------------------------------------------------------------------

def ProcessCommand_config( configArgs ):
	ReadConfigFile()
	
	nargs = len( configArgs )
	if (nargs < 1) or (nargs > 2):
		ProcessCommand_help( "config" )
		sys.exit( -2 )
	
	if configArgs[0] == "list":
		for section, sectionDicts in gRepositories.items():
			print( section )
			for key, value in sectionDicts.items():
				print( "        %s = %s" % (key, value) )
	
	section, _, key = configArgs[0].partition(".")
	if nargs == 1:
		if section in gRepositories:
			if key in gRepositories[section]:
				print( gRepositories[section][key] )
	elif nargs == 2:
		sectionLine = '[project "%s"]\n' % section
		keyLine = '        %s = %s\n' % (key, configArgs[1])
		
		sectionFound = False
		with open( ".forest/forest.conf", "r" ) as f:
			lines = f.readlines()
			for i in range( len( lines ) ):
				line = lines[i]
				if line.startswith( sectionLine ):
					lines.insert( i+1, keyLine )
					sectionFound = True
		
			if not sectionFound:
				lines.append( sectionLine )
				lines.append( keyLine )
			
		with open( ".forest/forest.conf", "w" ) as f:
			f.writelines( lines )
			f.flush()

#----------------------------------------------------------------------------------------------------------------------------
#	ProcessCommand_foreach
#----------------------------------------------------------------------------------------------------------------------------

def ProcessCommand_foreach( forEachArgs ):
	ReadConfigFile()
	
	nargs = len( forEachArgs )
	if (nargs < 1) or (nargs > 2):
		ProcessCommand_help( "foreach" )
		sys.exit(-2)
	
	command = None
	name = None
	if (nargs == 2) and (forEachArgs[0] == "-f"):
		if not os.path.exists( forEachArgs[1] ):
			print( 'Script file "%s" doesn\'t exist!' % forEachArgs[1] )
			sys.exit( -2 )
		
		name = forEachArgs[1]
		command = os.path.abspath( forEachArgs[1] )
	else:
		name = forEachArgs[0]
		command = forEachArgs[0]
	
	for sectionName, section in gRepositories.items():
		if sectionName != "global":
			path = section["path"]
			print( '"%s" at path: "%s"' % (name, path) )
			current = os.getcwd()
			os.chdir(path)
			output = commands.getoutput( command )
			print( output + "\n" )
			os.chdir(current)

#----------------------------------------------------------------------------------------------------------------------------
# ProcessCommand_status
#----------------------------------------------------------------------------------------------------------------------------

def ProcessCommand_status( statusArgs ):
	ProcessCommand_foreach( ["git status"] )

#----------------------------------------------------------------------------------------------------------------------------
# ProcessCommand_pull
#----------------------------------------------------------------------------------------------------------------------------

def	ProcessCommand_pull( pullArgs ):
	ReadConfigFile()
	
	fullPath = None
	for sectionName, section in gRepositories.items():
		if "path" in section:
			path = section["path"]
			if path == None:
				print( "No path for section: " + sectionName )
				sys.exit( -2 )
			fullpath = os.path.join( path, ".git" )
			
			# clone the path if we don't have it yet, otherwise just pull.
			if os.path.exists( fullpath ) == False:
				url = urlForSection( sectionName )
				print( "Cloning '%s' -> '%s'..." % (url, path) )
				command = "git clone %s %s 2>&1" % (url, path)
				err, output = commands.getstatusoutput( command )
				print( output )
				if err != 0:
					sys.exit( err )
				print( "done\n" )
			else:
				os.chdir( path )
				print( 'Updating "%s"' % path )
				command = "git pull 2>&1"
				err, output = commands.getstatusoutput( command )
				print( output )
				if err != 0:
					sys.exit( err )
				os.chdir( ".." )

#----------------------------------------------------------------------------------------------------------------------------
#	ProcessCommand_error
#----------------------------------------------------------------------------------------------------------------------------

def ProcessCommand_error( errorArgs ):
	if errorArgs:
		print( 'Invalid command: "%s"' % errorArgs[0] )
	ProcessCommand_help()

#----------------------------------------------------------------------------------------------------------------------------
#	main
#----------------------------------------------------------------------------------------------------------------------------

def main( argv=None ):
	if argv is None:
		argv = sys.argv
	
	# Set up options for the command line that we support.
	if   "help"    == argv[1]:
		ProcessCommand_help( argv[2:] )
	elif "init"    == argv[1]:
		ProcessCommand_init( argv[2:] )
	elif "config"  == argv[1]:
		ProcessCommand_config( argv[2:] )
	elif "foreach" == argv[1]:
		ProcessCommand_foreach( argv[2:] )
	elif "pull"    == argv[1]:
		ProcessCommand_pull( argv[2:] )
	elif "push"    == argv[1]:
		ProcessCommand_push( argv[2:] )
	elif "status"  == argv[1]:
		ProcessCommand_status( argv[2:] )
	elif "tag"     == argv[1]:
		ProcessCommand_tag( argv[2:] )
	else:
		ProcessCommand_error( argv[1:] )
	
	return 0

if __name__ == "__main__":
	sys.exit(main())
